​ 城市扩建的规划是个令人头疼的大问题。规划师设计了一个极其复杂的方案：当城市规模扩大之后，把与原来城市结构一样的区域复制或旋转 90 度之后建设在原来的城市周围
（详细地说，将原来的城市复制一遍放在原城市上方，将顺时针旋转 90 度后的城市放在原城市的左上方，将逆时针旋转 90 度后的城市放在原城市的左方），再用道路将四部分首尾连接起来，如下图所示。
容易看出，扩建后的城市的各个房屋仍然由一条道路连接。定义 N 级城市为拥有 22N 座房屋的城市。对于任意等级的城市，从左上角开始沿着唯一的道路走，依次为房屋标号，就能够得到每间房及的编号了。
住在其中两间房屋里的人们想知道，如果城市发展到了一定等级，他俩各自所处的房屋之间的直线距离是多少。
你可以认为图中的每个格子都是边长为 10 米的正方形，房屋均位于每个格子的中心点上（ T 次询问，每次输入等级 N ，两个编号 S、D ，求 S 与 D 之间的直线距离。

https://oj.haizeix.com/problem/239
#include<algorithm>
#include <iostream>
#include  <cstdlib>
#include  <cstring>
#include   <string>
#include   <vector>
#include   <cstdio>
#include    <queue>
#include    <stack>
#include    <ctime>
#include    <cmath>
#include      <map>
#include      <set>
#define ll long long
#define INF 0x3f3f3f3f
#define db1(x) cout<<#x<<"="<<(x)<<endl
#define db2(x,y) cout<<#x<<"="<<(x)<<", "<<#y<<"="<<(y)<<endl
#define db3(x,y,z) cout<<#x<<"="<<(x)<<", "<<#y<<"="<<(y)<<", "<<#z<<"="<<(z)<<endl
#define db4(x,y,z,a) cout<<#x<<"="<<(x)<<", "<<#y<<"="<<(y)<<", "<<#z<<"="<<(z)<<", "<<#a<<"="<<(a)<<endl
#define NUMBER_OF_THREADS   10
using namespace std;

void getans(long long n,long long s,long long &x,long long &y)
{
    if(n==1)
    {
        if(s==1)x=0,y=0;
        else if(s==2)x=0,y=1;
        else if(s==3)x=1,y=1;
        else x=1,y=0;
        return;
    }

    long long L=1LL<<(n-1),block=L*L,xx,yy;
    if(s<=block)
    {
        getans(n-1,s,xx,yy);
        x=yy,y=xx;
    }
    else if(s<=2*block)
    {
        getans(n-1,s-block,xx,yy);
        x=xx,y=yy+L;
    }
    else if(s<=3*block)
    {
        getans(n-1,s-2*block,xx,yy);
        x=xx+L,y=yy+L;
    }
    else
    {
        getans(n-1,s-3*block,xx,yy);
        x=2*L-yy-1,y=L-xx-1;
    }
    return;
}

int main(void)
{
    #ifdef test
    freopen("in.txt","r",stdin);
//    freopen("out.txt","w",stdout);
    clock_t start=clock();
    #endif //test

    int T;
    for(scanf("%d",&T);T--;)
    {
        long long n,s,d;
        scanf("%lld%lld%lld",&n,&s,&d);
        long long sx,sy,dx,dy;
        getans(n,s,sx,sy);
        getans(n,d,dx,dy);
        printf("%.0lf\n",10.0*sqrt((sx-dx)*(sx-dx)+(sy-dy)*(sy-dy)));
    }

    #ifdef test
    clock_t end=clock();
    double endtime=(double)(end-start)/CLOCKS_PER_SEC;
    printf("\n\n\n\n\n");
    cout<<"Total time:"<<endtime<<"s"<<endl;        //s为单位
    cout<<"Total time:"<<endtime*1000<<"ms"<<endl;    //ms为单位
    #endif //test
    return 0;
}
